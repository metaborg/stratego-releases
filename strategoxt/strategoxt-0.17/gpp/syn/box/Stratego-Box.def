definition
module Stratego-Sugar-Overlays
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Terms

exports
  sorts Overlay
  context-free syntax
    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports
  Stratego-Core-Identifiers
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules

exports
 
  sorts ScopeLabels
  context-free syntax

    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}

    {DynRuleScopeId ","}*   -> ScopeLabels
    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
  context-free syntax

    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}

    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}

    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}

    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}

    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
    RuleDec                     -> DynRuleId {cons("DynRuleId")}

    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax

    Id                          -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}

  sorts RuleNames
  context-free syntax
    {Id ","}*				  -> RuleNames
    "~" Term				  -> RuleNames {cons("RuleNames")}

    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}

  syntax
    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}


  context-free syntax
    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}

    Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
  > {

    %% no space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% 1 space after RuleNames
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleUnionFix")}

    %% no space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    %% 1 space after RuleNames
    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

    }
  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}

  context-free priorities
    StrategyAngle Term 		          -> Strategy {cons("BA")}
  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
  > Strategy "/" RuleNames "\\" 
                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies
exports

  sorts RuleDef
  context-free syntax
    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}

    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}

    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}

  sorts Rule RuleCond
  context-free syntax
    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}

    "where" Strategy -> RuleCond {cons("WhereClause")}
    "with"  Strategy -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports
  Stratego-Core-Strategies
  Stratego-Sugar-Terms
  Stratego-Sugar-Constants
  Stratego-Sugar-Signatures

exports
  context-free syntax
    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID 				  	  -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle
  context-free syntax

    %% Abstraction

    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}

    %% Match and build

    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}

     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
     StrategyAngle Term 		  -> Strategy {cons("BA")}
     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}

    %% Combinators

    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}

    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}

    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}

    %% Primitives

    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}

    %% Congruence operators

    String 				  -> Strategy {cons("StrCong")}
    Int 				  -> Strategy {cons("IntCong")}
    Real 				  -> Strategy {cons("RealCong")}
    Char 			 	  -> Strategy {cons("CharCong")}

    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}

    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}

    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}

    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
   "(" Strategy  ")" 		          -> Strategy {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}

%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
%%    Id "^" Id				  -> Mod {cons("Mod")}
    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}

%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}

  %% Syntactic sugar sugar

  sorts SwitchCase
  context-free syntax

    SVar  		  		  -> Strategy {cons("CallNoArgs")}
    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
    "(" Rule ")" 			  -> Strategy {cons("SRule")}
    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}

    "if" Strategy "then" Strategy 
                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}

    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase*
         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}

    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}

    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}

    Term ":=" Term			  -> Strategy {cons("Assign")}

  %% Priorities

  context-free priorities
    { Strategy StrategyCurly		  -> Strategy
      Strategy "#" StrategyParen          -> Strategy
    }
  > { "!" Term 				  -> Strategy
      "?" Term 				  -> Strategy
    }
  > StrategyAngle Term 		          -> Strategy
  > Strategy "=>" Term 		  	  -> Strategy
  > Strategy ";" Strategy 		  -> Strategy
  > {right: 
     Strategy "+" Strategy 		  -> Strategy
     Strategy "<+" Strategy 		  -> Strategy
     Strategy "+>" Strategy 		  -> Strategy
     
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy
    }

  context-free priorities
    Strategy 				  -> StrategyMid
  > Strategy "+" Strategy 		  -> Strategy

  context-free priorities
    { Strategy StrategyCurly      -> Strategy
      Strategy "#" StrategyParen  -> Strategy
    }
    .> Term ":=" Term -> Strategy


module Stratego-Sugar-Terms
imports
  Stratego-Core-Terms
  Stratego-Sugar-Strategies

exports
  sorts LID
  context-free syntax
    LId 			-> LID  {cons("ListVar")}
    LID				-> Var  {cons("Var")}
    LID				-> ID

  context-free syntax
    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
    "_" Term 			 -> Term {cons("BuildDefault"),prefer}

    Char 			 -> PreTerm {cons("Char")}

    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
    PreTerm                      -> Term {cons("NoAnnoList")}

    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}

    StrategyAngle		 -> PreTerm {cons("RootApp")}
    StrategyAngle		 -> Term {cons("RootApp"),prefer}

    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports
  Stratego-Core-Signatures
  Stratego-Sugar-Constants

exports

  sorts Sort
  context-free syntax
    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}

  sorts Kind
  context-free syntax
    "*" 			-> Kind {cons("Star")}
    "**" 			-> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants
exports
  sorts Sdecl
  context-free syntax
    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}

  sorts Sort
  context-free syntax
    LCID 			 -> Sort {cons("SortVar")}
    UCID 			 -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}

  sorts Opdecl
  context-free syntax
    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
           ":" Type 		-> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType
  context-free syntax
    Sort	                -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
    "(" Type ")"                -> ArgType {bracket}
    ConstType			-> ArgType
    Type	                -> RetType
    FunType			-> RetType {reject}

    FunType			-> Type
    ConstType			-> Type

  %%%
   %% Restriction is required for the Sort* in Sdecl: List(a) is
   %% ambiguous.
   %%%
  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports
  Stratego-Core-Identifiers
  Stratego-Core-Constants

exports
  sorts ID Var Wld
  context-free syntax
    Id 				-> Var  {cons("Var")}
    Id				-> ID
    %% ":" Var                  -> Var  {cons("SeqVar")}

  sorts Term PreTerm
  context-free syntax
    Var 			 -> PreTerm 
    Var 			 -> Term {prefer}

    "_" 			 -> Wld {cons("Wld")}
    Wld 			 -> PreTerm
    Wld 			 -> Term {prefer}

    Int 			 -> PreTerm {cons("Int")}
    Real 			 -> PreTerm {cons("Real")}
    String 			 -> PreTerm {cons("Str")}

    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}

    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}

    Var "@" Term 		 -> Term {cons("As"),prefer}
    Var "@" PreTerm 		 -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
  > Var "@" Term 		 -> Term {cons("As")}

module Stratego-Core-Strategies
imports
  Stratego-Core-Terms
  Stratego-Core-Constants
  Stratego-Core-Signatures

exports
  sorts Def
  context-free syntax
    StrategyDef					 -> Def 
    Id						 -> SVar {cons("SVar")}
    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}

    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}


  sorts StrategyDef
  context-free syntax
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}

    "external"
    Id "(" {Typedid ","}* 
       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}


  sorts Typedid
  context-free syntax
    ID ":" Type 			  -> Typedid {cons("VarDec")}


  sorts Strategy SVar StrategyParen StrategyMid 
  context-free syntax
    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}

    "fail" 				  -> Strategy {cons("Fail")}
    "id" 				  -> Strategy {cons("Id")}

    %% Match and build

    "?" Term 				  -> Strategy {cons("Match")}
    "!" Term 				  -> Strategy {cons("Build")}
    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}

    %% Combinators

    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
    Strategy "<" StrategyMid 
             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    Strategy 				  -> StrategyMid

    %% Primitives

    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}

    %% Traversal

    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}

  %% Priorities

  context-free priorities
    { "!" Term 				  -> Strategy {cons("Build")}
      "?" Term 				  -> Strategy {cons("Match")}
    }
  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
  > {right: 
     Strategy "<" StrategyMid 
              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports
  Stratego-Core-Identifiers
  Stratego-Core-Strategies
  Stratego-Core-Signatures

exports 
  sorts Module
  context-free syntax
    "module" ModName Decl* 	 -> Module {cons("Module")}
    "specification" Decl*	 -> Module {cons("Specification")}

  sorts Decl 
  context-free syntax
    "imports" ImportModName* 	-> Decl {cons("Imports")}
    "strategies" Def* 		-> Decl {cons("Strategies")}
    "signature" Sdecl*  	-> Decl {cons("Signature")}

  sorts ImportModName
  context-free syntax
    ModName              -> ImportModName {cons("Import")}
  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports
  Stratego-Core-Modules
  Stratego-Sugar-Strategies
  Stratego-Sugar-Signatures
  Stratego-Sugar-Overlays
  Stratego-Sugar-Rules

exports 

  sorts Decl Def
  context-free syntax
    "rules" Def* 		-> Decl {cons("Rules")}
    "overlays" Overlay* 	-> Decl {cons("Overlays")}

    RuleDef 			-> Def 


module Stratego-Core-Constants
exports
  sorts Int Real String StrChar
  lexical syntax
    [\-]? [0-9]+ 		-> Int
    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
    "\"" StrChar* "\"" 		-> String
    ~[\"\\] 			-> StrChar
    [\\] [\"tnr\\] 		-> StrChar


module Stratego-Sugar-Constants
imports Stratego-Core-Identifiers Stratego-Core-Constants
exports
  sorts Char CharChar
  lexical syntax
    "'" CharChar "'"		-> Char
    ~[\']			-> CharChar
    [\\] [\'ntr\ ]		-> CharChar
    Char		 	-> Id {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart
  lexical syntax
    {ModNamePart "/"}+ -> ModName
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]
  lexical syntax
    "imports" 		-> ModName {reject}
    "overlays" 		-> ModName {reject}
    "rules" 		-> ModName {reject}
    "signature" 	-> ModName {reject}
    "strategies" 	-> ModName {reject}

  sorts Id LId LCID UCID Wld
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
    [\'] [a-z]+                       -> Id

    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID

  lexical restrictions
    Id   -/- [a-zA-Z0-9\'\-\_\*]
    LId  -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id {reject}
    "'"     -> Id {reject}

    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all"
    "case" %% not reserved kw
    "constructors"
    "else" %% not reserved kw
    "end" %% not reserved kw
    "external" %% not reserved kw
    "fail"
    "id"
    "if" %% not reserved kw
    "in"
    "imports" %% not reserved kw
    "let"
    "module"
    "not"
    "one"
    "overlays"
    "otherwise" %% not reserved kw
    "prim"
    "rec" %% not reserved kw
    "rules"
    "script"
    "signature"
    "some"
    "sorts"
    "strategies"
    "stratego"
    "switch" %% not reserved kw
    "test"
    "then" %% not reserved kw
    "where"
    "import-term"
      -/- [a-zA-Z0-9\'\-\_]
  
  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword
  lexical syntax
    "all"               -> Keyword
    "constructors" 	-> Keyword
    "fail" 		-> Keyword
    "id" 		-> Keyword
    "in" 		-> Keyword
    "let" 		-> Keyword
    "module" 		-> Keyword
    "not" 		-> Keyword
    "one" 		-> Keyword
    "overlays" 		-> Keyword
    "prim" 		-> Keyword
    "rules" 		-> Keyword
    "script" 		-> Keyword
    "signature" 	-> Keyword
    "some" 		-> Keyword
    "sorts" 		-> Keyword
    "strategies" 	-> Keyword
    "stratego" 		-> Keyword
    "test" 		-> Keyword
    "where" 		-> Keyword
    "import-term"	-> Keyword


module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
  lexical syntax
    [\t\ \n\r]			-> Ws

    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
    "/*" CommChar* "*/"	-> LongCom
				-> Eof  

    ~[\*]     -> CommChar

    "*"       -> Asterisk
    Asterisk  -> CommChar

  lexical restrictions
    Asterisk -/- [\/]
    Eof      -/- ~[]

  lexical syntax
    ShortCom 	-> LAYOUT
    LongCom 	-> LAYOUT
    Ws 		-> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\*]
    LAYOUT? -/- [\/].[\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout
%%exports
%%  sorts VeryLongCom Eof VLCchar Backslash
%%  lexical syntax
%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
%%    "\\begin{code}" 			   -> VeryLongCom
%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
%%    ~[\\] 				   -> VLCchar
%%    Backslash 				   -> VLCchar
%%    [\\] 				   -> Backslash

%%  lexical restrictions
%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
%%    Eof -/- ~[]

%%  lexical syntax
%%    VeryLongCom -> LAYOUT



module Stratego-Sugar
imports
  Stratego-Sugar-Layout
  Stratego-Core-Identifiers
  Stratego-Sugar-Constants 
  Stratego-Sugar-Modules
  Stratego-Sugar-Signatures
  Stratego-Sugar-Terms
  Stratego-Sugar-Strategies
  Stratego-Sugar-Rules
  Stratego-Sugar-DynamicRules
  Stratego-Sugar-Overlays

hiddens
  context-free start-symbols Module

module Stratego
imports Stratego-Sugar
hiddens
  context-free start-symbols Module

module StrategoRenamed
imports Stratego
          [ RuleNames      => StrategoRuleNames
            RuleDec        => StrategoRuleDec
            DynRuleScopeId => StrategoDynRuleScopeId
            DynRuleId      => StrategoDynRuleId
            DynRuleDef     => StrategoDynRuleDef
            ScopeLabels    => StrategoScopeLabels
            RuleCond       => StrategoRuleCond
            Rule           => StrategoRule
            RuleDef        => StrategoRuleDef
            Overlay        => StrategoOverlay
            SwitchCase     => StrategoSwitchCase
            StrategyCurly  => StrategoStrategyCurly
            StrategyAngle  => StrategoStrategyAngle
            Kind           => StrategoKind
            LID            => StrategoLID
            ImportModName  => StrategoImportModName
            Decl           => StrategoDecl
            Module         => StrategoModule
            StrategyParen  => StrategoStrategyParen
            Typedid        => StrategoTypedid
            StrategyDef    => StrategoStrategyDef
            SVar           => StrategoSVar
            Def            => StrategoDef
            Type           => StrategoType
            RetType        => StrategoRetType
            ArgType        => StrategoArgType
            FunType        => StrategoFunType
            ConstType      => StrategoConstType
            Opdecl         => StrategoOpdecl
            Sort           => StrategoSort
            Sdecl          => StrategoSdecl
            Wld            => StrategoWld
            ID             => StrategoID
            Var            => StrategoVar
            CharChar       => StrategoCharChar
            Char           => StrategoChar
            StrChar        => StrategoStrChar
            String         => StrategoString
            Real           => StrategoReal
            Int            => StrategoInt
            Keyword        => StrategoKeyword
            UCID           => StrategoUCID
            LCID           => StrategoLCID
            LId            => StrategoLId
            Id             => StrategoId
            ModNamePart    => StrategoModNamePart
            ModName        => StrategoModName
            Asterisk       => StrategoAsterisk
            CommChar       => StrategoCommChar
            Eof            => StrategoEof
            LongCom        => StrategoLongCom
            ShortCom       => StrategoShortCom
            Ws             => StrategoWs
            PreTerm        => StrategoPreTerm
            Term           => StrategoTerm
            StrategyMid    => StrategoStrategyMid
            Strategy       => StrategoStrategy ]


module Box-Disambiguation
exports
  context-free restrictions
    LAYOUT? -/- [\ \t\n\%]

module Box-Layout
exports
  lexical syntax
    "%%" ~[\n]* "\n" -> LAYOUT
    [\ \t\n\r] -> LAYOUT

  context-free restrictions
    LAYOUT? -/- [\ \t\n\13]

module Box-Operators
exports

  %% Deprecated, but used by Transformers.
  context-free syntax
    BOX* -> BOX-LIST

  exports
      sorts SPACE-SYMBOL S-OPTION

      context-free syntax
         SPACE-SYMBOL "=" NatCon -> S-OPTION     {cons("SOpt")}
         SPACE-SYMBOL "=" BOX    -> S-OPTION     {cons("SOptB")}

%% Below all supported space options are defined. The \textsf{hs} option is
%% used to define the horizontal layout between boxes. The \textsf{vs}
%% option defines the amount of vertical layout between boxes (the number of
%% newlines between boxes in a vertical context). The \textsf{is} option
%% defines indentation between boxes within a vertical context. Not every
%% combination of space option and BOX operator makes sense. E.g.\ the
%% modification of the vertical offset in combination of the \textsf{H}
%% operator does not make any sense.

      context-free syntax
         "vs"                    -> SPACE-SYMBOL {cons("VS")}
         "hs"                    -> SPACE-SYMBOL {cons("HS")}
         "is"                    -> SPACE-SYMBOL {cons("IS")}

%%\subsection{Positional BOX Operators}
%% Smaller boxes can be composed to form new boxes using positional BOX
%% operators that specify the relative ordering of sub boxes.
%%
%% The \textsf{H} operator is used to format a list of boxes horizontally.
%% The operator only supports the \textsf{hs} space option to control the
%% amount of horizontal layout between its sub-boxes. The \textsf{V}
%% operator is used to format a list of boxes vertically. The operator
%% supports the \textsf{vs} and \textsf{is} space options to control the
%% amount of vertical layout and the amount of indentation between its
%% sub-boxes, respectively. The \textsf{HV} operator is used to format a
%% list of boxes horizontally \emph{or} vertically, depending on the
%% available width. The operator calculates an optimal combination of
%% \textsf{H} and \textsf{V} operators in such a way that the number of
%% lines occupied is minimized. Because the \textsf{HV} is a combination of
%% the \textsf{H} and \textsf{V} operators, it supports all space
%% options of these operators (\textsf{hs}, \textsf{vs}, and \textsf{is}).

   exports
      context-free syntax
         "H" S-OPTION*  "[" BOX* "]"  -> BOX {cons("H")}
         "V" S-OPTION*  "[" BOX* "]"  -> BOX {cons("V")}
         "HV" S-OPTION* "[" BOX* "]" -> BOX {cons("HV")}

%% The \textsf{ALT} operator is used to choose between two alternative BOX
%% expressions depending on the available width. When its first argument
%% fits on the current line, that BOX expression is used. Otherwise, the
%% \textsf{ALT} operator chooses the second alternative. No space options
%% are supported by this operator.

   exports
      context-free syntax
         "ALT" "[" BOX BOX "]" -> BOX {cons("ALT")}

%% Alignments are implemented by means of two BOX operators: \textsf{A} and
%% \textsf{R}. The arguments of the \textsf{A} operator are \textsf{R}
%% boxes. Each \textsf{R} BOX represents a row, each element of an
%% \textsf{R} BOX represents an entry in the alignment. The number of
%% arguments of an
%% \textsf{R} BOX may not exceed the number of columns of the alignment. For
%% each column the user can specify whether the alignment should be left,
%% right, or centered. The number of alignment indications should be equal
%% to the number of columns. Each alignment indication can be extended with
%% space options, specifying the horizontal layout between columns. The
%% \textsf{A} operator supports the \textsf{vs} space option which defines
%% the vertical layout between individual rows.
%%
%% \textsf{R} boxes occurring outside an alignment are formatted as
%% \text{HV} operator. This behavior enables the use of an alternative
%% formatting (not based on the \textsf{A} operator) of alignments within an
%% \textsf{ALT} operator. The \textsf{R} operator therefore supports all
%% space options of the \textsf{HV} operator.

   exports
      sorts A-OPTION A-OPTIONS

      context-free syntax
         "A" A-OPTIONS S-OPTION* "[" BOX* "]" -> BOX       {cons("A")}
         "R" S-OPTION* "[" BOX* "]"           -> BOX       {cons("R")}

%% Justification of columns and horizontal layout between columns can be
%% specified using A-OPTIONS. An A-OPTION is composed of an alignment
%% indicator (\textsf{l} for left, \textsf{r} for right, and \textsf{c} for
%% centered alignment), and space options (only the \textsf{hs} option is
%% supported).

         "l" S-OPTION*                            -> A-OPTION  {cons("AL")}
         "c" S-OPTION*                            -> A-OPTION  {cons("AC")}
         "r" S-OPTION*                            -> A-OPTION  {cons("AR")}
         "(" {A-OPTION ","}* ")"                  -> A-OPTIONS {cons("AOPTIONS")}

%%\subsection{Non-Positional BOX Operators}
%%
%% There are four different types of non-positional BOX operators: font
%% operators to change the textual appearance of BOX expressions, cross
%% reference operators to create links between boxes, the comment operator
%% to indicate that a BOX expression contains comments, and the line
%% operator to draw lines of characters of arbitrary length.
%%
%%
%% BOX font operators are used to change the textual appearance of the
%% argument BOX expression. Fonts can be characterized by the parameters
%% font name (\textsf{fn}), font family (\textsf{fm}), font series
%% (\textsf{se}), font shape (\textsf{sh}), font size (\textsf{sz}), and
%% font color (\textsf{cl}). The most general font operator is \textsf{F}.
%% By means of font parameters the desired font can be controlled.

   exports
      sorts FID FONT-PARAM F-OPTION FONT-OPERATOR

      lexical syntax
         [A-Za-z]+ -> FID

      context-free syntax
         FONT-PARAM "=" NatCon     -> F-OPTION      {cons("FNAT")}
         FONT-PARAM "=" FID        -> F-OPTION      {cons("FFID")}

      context-free syntax
         "F" F-OPTION*             -> FONT-OPERATOR {cons("F")}
         FONT-OPERATOR "[" BOX "]" -> BOX           {cons("FBOX")}
         "fn"                      -> FONT-PARAM    {cons("FN")}
         "fm"                      -> FONT-PARAM    {cons("FM")}
         "se"                      -> FONT-PARAM    {cons("SE")}
         "sh"                      -> FONT-PARAM    {cons("SH")}
         "sz"                      -> FONT-PARAM    {cons("SZ")}
         "cl"                      -> FONT-PARAM    {cons("CL")}

%% By using the \textsf{F} font operator, fonts are defined statically.
%% BOX also support fonts to be defined dynamically using special
%% font operators.  These operators are used to format specific language
%% constructs like keywords and variables. The mapping from these
%% operators to fonts is deferred to the back-ends.

   exports
      context-free syntax
         "KW"   -> FONT-OPERATOR {cons("KW")}
         "VAR"  -> FONT-OPERATOR {cons("VAR")}
         "NUM"  -> FONT-OPERATOR {cons("NUM")}
         "MATH" -> FONT-OPERATOR {cons("MATH")}

%% The \textsf{LBL} operator is used to label BOX terms. A labeled BOX term
%% can be refered to using the \textsf{REF} operator.  The first argument of
%% the \textsf{LBL} and \textsf{REF} operators denote the name of the label.
%% The second argument of the \textsf{LBL} operator denotes the BOX term to
%% label. The second argument of the \textsf{REF} operator denotes the BOX
%% containing the reference. Both operators do not support any space
%% options.

   exports
      context-free syntax
         "LBL" "[" BoxLiteral BOX "]" -> BOX {cons("LBL")}
         "REF" "[" BoxLiteral BOX "]" -> BOX {cons("REF")}

%% Comments can be formatted using the \textsf{C} operator. The operator
%% supports the \textsf{is} space option to denote the indentation level of
%% comments.

   exports
      context-free syntax
         "C" S-OPTION* "[" BOX* "]" -> BOX {cons("C")}

%% The \textsf{L} operator  is used to construct horizontal bars of fixed
%% \emph{or} variable width. A bar of fixed width can be constructed by
%% specifying its width as a fixed number. A bar of variable width can be
%% constructed by specifying a BOX expressions as width parameter. The
%% second argument of the \textsf{L} operator specifies the symbol of which
%% the bar should be constructed. The \textsf{L} operator does not support
%% any space options.

   exports
      context-free syntax
         "L" "[" BOX BOX "]"    -> BOX {cons("L")}
         "L" "[" NatCon BOX "]" -> BOX {cons("LNAT")}

module Box-Literal
exports
  sorts BoxLiteral
  lexical syntax
    "\\" ~[] -> AlphaNumericalEscChar {avoid}
    "\\" [01] [0-9] [0-9] -> DecimalEscChar
    "\\" "2" [0-4] [0-9]  -> DecimalEscChar
    "\\" "2" "5" [0-5]    -> DecimalEscChar

    AlphaNumericalEscChar -> EscChar
    DecimalEscChar        -> EscChar

    ~[\0-\31\"\\] \/ [\t\n] -> L-Char
    EscChar                 -> L-Char

    "\"" L-Char* "\""             -> QLiteral
    [A-Za-z\-\_] [A-Za-z0-9\-\_]* -> UQLiteral

    QLiteral  -> Literal
    UQLiteral -> Literal

    QLiteral -> BoxLiteral

  sorts NatCon
  lexical syntax
    [0-9]+ -> NatCon


module Box-Base
   exports
      sorts BOX

module Box-Atoms
   exports
      imports Box-Base Box-Literal

   exports
      context-free syntax
         BoxLiteral            -> BOX {cons("S")}

module Box
  hiddens
    context-free start-symbols BOX
  exports
    imports Box-Atoms Box-Operators Box-Layout Box-Disambiguation

module Stratego-Box
imports Box StrategoRenamed
hiddens
  context-free start-symbols StrategoModule

exports
  context-free syntax

                BOX      -> StrategoTerm  {cons("ToTerm"), avoid}
          "|["  BOX "]|" -> StrategoTerm  {cons("ToTerm"), prefer}
    "box" "|["  BOX "]|" -> StrategoTerm  {cons("ToTerm")}

           "|["  BOX* "]|" -> StrategoTerm {cons("ToTerm")}
    "box*" "|["  BOX* "]|" -> StrategoTerm {cons("ToTerm")}

    "~"  StrategoTerm    -> BOX   {cons("FromTerm"), prefer}
    "~*" StrategoTerm    -> BOX*  {cons("FromTerm"), prefer}

    "~lit:" StrategoTerm -> BoxLiteral {cons("FromTerm"), prefer}

  variables
    "b" [0-9]*     -> BOX
    "b" [0-9]* "*" -> BOX*
    "s" [0-9]*     -> BoxLiteral
